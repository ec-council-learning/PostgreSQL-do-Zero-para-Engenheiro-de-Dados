Os servidores master e slave são de muitas formas vagamente conectados. Ações no master terá um efeito sobre o slave. Como resultado, existe um potencial para interações negativas ou conflitos entre eles. O conflito mais fácil de entender é o desempenho: se um carregamento de dados enorme está ocorrendo no master, então isso vai gerar um fluxo semelhante de registros de WAL no slave, de modo consultas no slave poderá lutar por recursos do sistema, tais como I/O.

Existem também outros tipos de conflitos que podem ocorrer com Hot-Standby. Estes conflitos são difíceis no sentido de que as consultas possam ter necessidade de ser cancelada e, em alguns casos, sessões desconectadas para resolvê-los, os conflitos incluem:

Access Exclusive produzem bloqueios exclusivos no servidor master, incluindo bloqueio explícito a diversas ações de DDL, conflito com acesso a tabelas em consultas no slave.
Eliminando uma tabela no master, conflita com consultas no slave.
Aplicação de VACUUM no WAL, conflita com as operações slave cuja as tuplas ainda vêem linhas que serão removidas.
No servidor master, nestes casos, simplesmente resultam em espera; e o usuário pode optar por cancelar qualquer uma das ações conflitantes. No entanto, no slave não há escolha: a ação WAL-logged já ocorreu no master de modo que o slave não pode deixar de aplicá-la. Além disso, permitindo a aplicação de WAL que espere indefinidamente pode ser muito indesejável, porque o slave se tornará cada vez mais distante master. Portanto, é fornecido um mecanismo para cancelar a força consultas no slave que conflitam.

Quando uma consulta conflitante é rápida, é tipicamente desejável permitir que conclua atrasando o WAL um pouco; mas um longo atraso no WAL geralmente não é desejável. Assim, o mecanismo de cancelamento possui os parâmetros, max_standby_archive_delay e max_standby_streaming_delay, que definem o atraso máximo permitido no WAL. consultas conflitantes serão cancelada uma vez que tenha levado mais tempo do que a configuração definida. Existe dois parâmetros para que os diferentes valores de atraso possam ser especificados para o caso de leitura de dados do arquivo de WAL versus a leitura de dados do WAL via streaming replication.

Em um servidor slave que existe principalmente para alta disponibilidade, é melhor definir os parâmetros de atraso relativamente curtos, para que o servidor não fique muito atrás do master devido a atrasos causados por consultas no slave. No entanto, se o servidor slave é para a execução de consultas de longa execução, um valor alto ou até mesmo infinito pode ser preferível. Tenha em mente, contudo, que uma consulta de longa duração pode causar que outras sessões não vejam as mudanças recentes do master, caso haja adiamento da aplicação do WAL.

Uma vez que o atraso especificado pelo max_standby_archive_delay ou max_standby_streaming_delay foi ultrapassado, as consultas conflitantes serão canceladas. Consultas canceladas podem ser repetida imediatamente (depois de começar uma nova transação, é claro). Existe possibilidades de reparação se o número de cancelamentos no slave for considerada inaceitável. A primeira opção é para definir o parâmetro hot_standby_feedback, que impede que as linhas recentemente mortas seja removidas e assim conflitos de limpeza não ocorrem. Se você fizer isso, você deve observar que isso vai atrasar a limpeza de linhas mortas no master, que pode resultar em inchaço nas tabelas. No entanto, a situação de limpeza não será pior do que se as consultas no slabe estavessem ocorrendo diretamente no servidor master, e você ainda está recebendo o benefício de execução off-loading para o slave. Se slave conectar e desconectar com freqüência, você pode querer fazer ajustes para lidar com o período em que hot_standby_feedback não está sendo fornecido. Por exemplo, considere aumentar max_standby_archive_delay para que as consultas não sejam cancelados rapidamente por conflitos de WAL durante os períodos desconectados. Você também deve considerar aumentar o max_standby_streaming_delay para evitar cancelamentos rápidas por entradas de WAL vindos do streaming replication.

Outra opção é aumentar vacuum_defer_cleanup_age no servidor master, de modo que as linhas mortas não serão limpas tão rapidamente como seriam normalmente. Isso permitirá mais tempo para consultas executarem antes de serem cancelados no slave, sem a necessidade de estabelecer um valor elevado no max_standby_streaming_delay. No entanto, é difícil garantir qualquer janela de tempo de execução específico com esta abordagem, uma vez que vacuum_defer_cleanup_age é medido em transações executadas no servidor master.

O número de consulta anuladas e os motivos podem ser vistos usando a visão do sistema pg_stat_database_conflicts no servidor slave. A visão do sistema pg_stat_database também contém um resumo das informações.

Documentação Oficial: http://www.postgresql.org/docs/9.5/static/hot-standby.html
